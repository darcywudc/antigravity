<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ©¡èƒ¶éš”éœ‡æ”¯åº§ä»¿çœŸ | Rubber Bearing Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 50%, #0f1928 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }

        .container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }

        .back-link {
            display: inline-block;
            color: #888;
            text-decoration: none;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .back-link:hover {
            color: #00d4ff;
        }

        h1 {
            font-size: 1.8rem;
            background: linear-gradient(90deg, #2ed573, #00d4ff, #7c3aed);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #888;
            font-size: 0.9rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 420px;
            gap: 20px;
        }

        @media (max-width: 1100px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        /* Canvas Area */
        .viz-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 20px;
        }

        #canvas {
            width: 100%;
            height: 500px;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            border-radius: 10px;
            display: block;
        }

        .view-tabs {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .view-tab {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #888;
            cursor: pointer;
            text-align: center;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .view-tab.active {
            background: rgba(46, 213, 115, 0.2);
            border-color: rgba(46, 213, 115, 0.4);
            color: #2ed573;
        }

        .view-tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.08);
        }

        /* Control Panel */
        .control-panel {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 20px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .section {
            margin-bottom: 18px;
        }

        .section h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .section h3::before {
            content: '';
            width: 3px;
            height: 12px;
            background: linear-gradient(180deg, #2ed573, #00d4ff);
            border-radius: 2px;
        }

        /* Formula Card */
        .formula-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #2ed573;
        }

        .formula-title {
            font-size: 0.8rem;
            color: #2ed573;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .formula-main {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.3rem;
            color: #fff;
            margin-bottom: 6px;
        }

        .formula-main .var {
            color: #f472b6;
        }

        .formula-desc {
            font-size: 0.75rem;
            color: #aaa;
            line-height: 1.4;
        }

        /* Scenario Selector */
        .scenario-btns {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .scenario-btn {
            flex: 1;
            padding: 12px 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #aaa;
            cursor: pointer;
            text-align: center;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .scenario-btn.active {
            background: rgba(46, 213, 115, 0.2);
            border-color: rgba(46, 213, 115, 0.4);
            color: #2ed573;
        }

        .scenario-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.08);
        }

        /* Support Grid Display */
        .support-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .support-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 12px 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s;
        }

        .support-card.normal {
            border-color: rgba(46, 213, 115, 0.3);
        }

        .support-card.warning {
            border-color: rgba(255, 165, 2, 0.4);
            background: rgba(255, 165, 2, 0.1);
        }

        .support-card.danger {
            border-color: rgba(255, 107, 107, 0.4);
            background: rgba(255, 107, 107, 0.1);
        }

        .support-label {
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 4px;
        }

        .support-value {
            font-size: 1rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }

        .support-detail {
            font-size: 0.65rem;
            color: #666;
            margin-top: 4px;
        }

        .support-stiffness {
            font-size: 0.7rem;
            margin-top: 4px;
            font-family: 'JetBrains Mono', monospace;
        }

        /* Summary Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }

        /* Eccentricity Display */
        .eccentricity-display {
            background: rgba(124, 58, 237, 0.1);
            border: 1px solid rgba(124, 58, 237, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
        }

        .ecc-title {
            font-size: 0.8rem;
            color: #7c3aed;
            margin-bottom: 8px;
        }

        .ecc-values {
            display: flex;
            justify-content: center;
            gap: 30px;
        }

        .ecc-item {
            text-align: center;
        }

        .ecc-label {
            font-size: 0.7rem;
            color: #888;
        }

        .ecc-value {
            font-size: 1.1rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            color: #f472b6;
        }

        /* Animation Controls */
        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #2ed573, #00d4ff);
            color: #000;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ccc;
        }

        /* Sliders */
        .slider-group {
            margin-bottom: 12px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.8rem;
            color: #ccc;
        }

        .slider-value {
            font-family: 'JetBrains Mono', monospace;
            color: #00d4ff;
        }

        input[type="range"] {
            width: 100%;
            height: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #2ed573, #00d4ff);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Torsion Alert */
        .torsion-alert {
            background: rgba(255, 107, 107, 0.15);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 15px;
            display: none;
        }

        .torsion-alert.show {
            display: block;
        }

        .torsion-title {
            color: #ff6b6b;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .torsion-text {
            font-size: 0.8rem;
            color: #ccc;
            line-height: 1.5;
        }

        /* Info Cards */
        .info-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        @media (max-width: 1000px) {
            .info-cards {
                grid-template-columns: 1fr;
            }
        }

        .info-card {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            padding: 18px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .info-card h4 {
            color: #2ed573;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .info-card p {
            color: #888;
            font-size: 0.78rem;
            line-height: 1.5;
        }

        .formula-inline {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 3px 6px;
            border-radius: 4px;
            color: #00d4ff;
            font-size: 0.7rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">â† è¿”å›æ¦‚è§ˆ</a>
            <h1>ğŸ¢ æ©¡èƒ¶éš”éœ‡æ”¯åº§ä»¿çœŸ</h1>
            <p class="subtitle">Rubber Bearing Simulation - åŸºäºçœŸå®å¸ƒç½®çš„åˆšåº¦åˆ†æ</p>
        </header>

        <div class="main-layout">
            <div class="viz-container">
                <canvas id="canvas"></canvas>
                <div class="view-tabs">
                    <div class="view-tab active" data-view="plan">ä¿¯è§†å›¾ (æ”¯åº§å¸ƒç½®)</div>
                    <div class="view-tab" data-view="forces">åŠ›çš„åˆ†å¸ƒ</div>
                    <div class="view-tab" data-view="stiffness">åˆšåº¦åˆ†å¸ƒ</div>
                </div>
            </div>

            <div class="control-panel">
                <!-- Core Formula -->
                <div class="formula-card">
                    <div class="formula-title">âš¡ æ©¡èƒ¶æ”¯åº§æ°´å¹³åˆšåº¦æ¨¡å‹</div>
                    <div class="formula-main">
                        K<sub>h</sub> = K<sub>0</sub> Ã— (1 - (<span class="var">P</span>/<span
                            class="var">P<sub>cr</sub></span>)Â²)
                    </div>
                    <div class="formula-desc">
                        æ°´å¹³åˆšåº¦éšç«–å‘è·è½½é™ä½ã€‚å½“ P â†’ P<sub>cr</sub> æ—¶ï¼ŒK<sub>h</sub> â†’ 0<br>
                        P<sub>cr</sub> = ä¸´ç•Œå±ˆæ›²è·è½½ï¼ˆä¸æ”¯åº§ç›´å¾„ã€æ©¡èƒ¶å±‚åšåº¦ç›¸å…³ï¼‰
                    </div>
                </div>

                <!-- Scenario Selection -->
                <div class="section">
                    <h3>å·¥å†µé€‰æ‹©</h3>
                    <div class="scenario-btns">
                        <div class="scenario-btn active" data-scenario="normal">æ­£å¸¸åˆ†å¸ƒ</div>
                        <div class="scenario-btn" data-scenario="eccentric">åå¿ƒåˆ†å¸ƒ</div>
                        <div class="scenario-btn" data-scenario="max_torsion">æœ€å¤§æ‰­è½¬</div>
                        <div class="scenario-btn" data-scenario="custom">è‡ªå®šä¹‰</div>
                    </div>
                </div>

                <!-- Support Grid -->
                <div class="section">
                    <h3>æ”¯åº§çŠ¶æ€ (è®¾è®¡é¢å‹ Ïƒ=15MPa)</h3>
                    <div class="support-grid" id="support-grid">
                        <!-- Generated by JS -->
                    </div>
                </div>

                <!-- Summary Stats -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">æ€»é‡ W</div>
                        <div class="stat-value" id="total-weight" style="color: #ffa502;">96.10 kN</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">å¹³å‡åˆšåº¦æ¯”</div>
                        <div class="stat-value" id="avg-stiffness" style="color: #2ed573;">98.5%</div>
                    </div>
                </div>

                <!-- Eccentricity Display -->
                <div class="eccentricity-display">
                    <div class="ecc-title">åˆšåº¦ä¸­å¿ƒåç§» (e = C<sub>S</sub> - C<sub>M</sub>)</div>
                    <div class="ecc-values">
                        <div class="ecc-item">
                            <div class="ecc-label">e<sub>x</sub></div>
                            <div class="ecc-value" id="ecc-x">0.00 m</div>
                        </div>
                        <div class="ecc-item">
                            <div class="ecc-label">e<sub>y</sub></div>
                            <div class="ecc-value" id="ecc-y">0.00 m</div>
                        </div>
                        <div class="ecc-item">
                            <div class="ecc-label">åå¿ƒç‡</div>
                            <div class="ecc-value" id="ecc-ratio">0.0%</div>
                        </div>
                    </div>
                </div>

                <!-- Torsion Alert -->
                <div class="torsion-alert" id="torsion-alert">
                    <div class="torsion-title">âš ï¸ æ‰­è½¬è€¦åˆè­¦å‘Š</div>
                    <div class="torsion-text" id="torsion-text">
                        åˆšåº¦ä¸­å¿ƒåç¦»è´¨å¿ƒï¼Œåœ°éœ‡åŠ›å°†äº§ç”Ÿæ‰­è½¬åŠ›çŸ© M<sub>T</sub> = F Ã— e
                    </div>
                </div>

                <!-- Seismic Control -->
                <div class="section">
                    <h3>åœ°éœ‡åŠ›è¾“å…¥</h3>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>æ°´å¹³åœ°éœ‡åŠ› F</span>
                            <span class="slider-value" id="force-value">0 kN</span>
                        </div>
                        <input type="range" id="force-slider" min="-100" max="100" value="0">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>åå¿ƒè°ƒèŠ‚</span>
                            <span class="slider-value" id="eccentric-value">0%</span>
                        </div>
                        <input type="range" id="eccentric-slider" min="0" max="100" value="0">
                    </div>
                </div>

                <!-- Animation Controls -->
                <div class="section">
                    <h3>åŠ¨ç”»æ§åˆ¶</h3>
                    <div class="btn-group">
                        <button class="btn btn-primary" id="btn-animate">â–¶ åœ°éœ‡æ¨¡æ‹Ÿ</button>
                        <button class="btn btn-secondary" id="btn-reset">â†º é‡ç½®</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Info Cards -->
        <div class="info-cards">
            <div class="info-card">
                <h4>ğŸ”§ æ©¡èƒ¶æ”¯åº§ç‰¹æ€§</h4>
                <p>
                    å¤©ç„¶æ©¡èƒ¶å å±‚éš”éœ‡æ”¯åº§ç”±äº¤æ›¿å å±‚çš„æ©¡èƒ¶ç‰‡å’Œé’¢æ¿ç»„æˆã€‚
                    <span class="formula-inline">K<sub>h</sub> = GÃ—A/T<sub>r</sub></span><br>
                    ç«–å‘è·è½½å¢å¤§ä¼šé™ä½æ°´å¹³åˆšåº¦ï¼ˆP-Î”æ•ˆåº”ï¼‰ã€‚
                </p>
            </div>
            <div class="info-card">
                <h4>âš–ï¸ åˆšåº¦ä¸­å¿ƒ C<sub>S</sub></h4>
                <p>
                    åˆšåº¦ä¸­å¿ƒç”±å„æ”¯åº§åˆšåº¦åŠ æƒè®¡ç®—ï¼š<br>
                    <span class="formula-inline">C<sub>S</sub> = Î£(K<sub>i</sub>Ã—x<sub>i</sub>) /
                        Î£(K<sub>i</sub>)</span><br>
                    å½“æ”¯åº§ååŠ›ä¸å‡åŒ€æ—¶ï¼ŒC<sub>S</sub> ä¼šåç¦»è´¨å¿ƒ C<sub>M</sub>ã€‚
                </p>
            </div>
            <div class="info-card">
                <h4>ğŸ”„ æ‰­è½¬è€¦åˆ</h4>
                <p>
                    å½“ e = C<sub>S</sub> - C<sub>M</sub> â‰  0 æ—¶ï¼Œæ°´å¹³åœ°éœ‡åŠ›ä¼šäº§ç”Ÿæ‰­è½¬åŠ›çŸ©ï¼š<br>
                    <span class="formula-inline">M<sub>T</sub> = F Ã— e</span><br>
                    å»ºç­‘ä¼šåŒæ—¶å‘ç”Ÿå¹³ç§»å’Œè½¬åŠ¨ã€‚
                </p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth - 40;
            canvas.height = 500;
        }
        resizeCanvas();
        window.addEventListener('resize', () => { resizeCanvas(); draw(); });

        // ============================================================
        // RUBBER BEARING DESIGN PARAMETERS
        // ============================================================

        // Target contact pressure (é¢å‹)
        const TARGET_PRESSURE = 15; // MPa

        // Material properties
        const SHEAR_MODULUS = 0.6; // MPa (G - shear modulus of rubber)
        const BULK_MODULUS = 2000; // MPa (K - bulk modulus of rubber, nearly incompressible)
        const RUBBER_LAYER_THICKNESS = 3; // mm per layer
        const NUM_RUBBER_LAYERS = 30; // number of rubber layers
        const TOTAL_RUBBER_THICKNESS = (RUBBER_LAYER_THICKNESS * NUM_RUBBER_LAYERS) / 1000; // m
        const STEEL_PLATE_THICKNESS = 2; // mm per steel plate

        // Reaction forces from image (kN) - Normal distribution
        // Row 1: 8, 11, 25 (top)
        // Row 2: 4, 16, 30 (bottom)
        const NORMAL_REACTIONS = [10.01, 22.77, 10.01, 10.07, 22.64, 10.07]; // kN
        const TOTAL_WEIGHT = NORMAL_REACTIONS.reduce((a, b) => a + b, 0);

        // Building geometry
        const BUILDING_WIDTH = 8; // m (X direction)
        const BUILDING_DEPTH = 6; // m (Y direction)

        // Support positions
        const SUPPORTS_CONFIG = [
            { label: '8', x: -BUILDING_WIDTH / 2, y: BUILDING_DEPTH / 2, isCenter: false },
            { label: '11', x: 0, y: BUILDING_DEPTH / 2, isCenter: true },
            { label: '25', x: BUILDING_WIDTH / 2, y: BUILDING_DEPTH / 2, isCenter: false },
            { label: '4', x: -BUILDING_WIDTH / 2, y: -BUILDING_DEPTH / 2, isCenter: false },
            { label: '16', x: 0, y: -BUILDING_DEPTH / 2, isCenter: true },
            { label: '30', x: BUILDING_WIDTH / 2, y: -BUILDING_DEPTH / 2, isCenter: false }
        ];

        // ============================================================
        // BEARING STIFFNESS CALCULATIONS
        // ============================================================

        // Calculate bearing diameter based on target pressure
        // Ïƒ = N / A  â†’  A = N / Ïƒ  â†’  D = âˆš(4A/Ï€)
        function calcDiameter(N_kN) {
            const N_N = N_kN * 1000; // Convert to N
            const sigma_Pa = TARGET_PRESSURE * 1e6; // Convert to Pa
            const A = N_N / sigma_Pa; // mÂ²
            const D = Math.sqrt(4 * A / Math.PI); // m
            return D;
        }

        // Shape factor S = D / (4 Ã— t_layer)
        function calcShapeFactor(D_m) {
            const t_layer_m = RUBBER_LAYER_THICKNESS / 1000;
            return D_m / (4 * t_layer_m);
        }

        // Horizontal (shear) stiffness: Kh = G Ã— A / Tr
        function calcHorizontalStiffness(D_m) {
            const A = Math.PI * Math.pow(D_m / 2, 2); // mÂ²
            const Kh = SHEAR_MODULUS * 1000 * A / TOTAL_RUBBER_THICKNESS; // kN/m
            return Kh;
        }

        // Vertical stiffness: Kv = Ec Ã— A / Tr
        // Ec = 6 Ã— G Ã— SÂ² (compression modulus for shape factor S)
        function calcVerticalStiffness(D_m) {
            const A = Math.PI * Math.pow(D_m / 2, 2); // mÂ²
            const S = calcShapeFactor(D_m);
            const Ec = 6 * SHEAR_MODULUS * S * S; // MPa
            const Kv = Ec * 1000 * A / TOTAL_RUBBER_THICKNESS; // kN/m
            return Kv;
        }

        // Critical buckling load: P_cr â‰ˆ Ï€Â² Ã— G Ã— A Ã— SÂ² / Tr
        function calcCriticalBucklingLoad(D_m) {
            const A = Math.PI * Math.pow(D_m / 2, 2); // mÂ²
            const S = calcShapeFactor(D_m);
            const P_cr = Math.PI * Math.PI * SHEAR_MODULUS * 1000 * A * S * S / TOTAL_RUBBER_THICKNESS; // kN
            return P_cr;
        }

        // Effective horizontal stiffness with P-delta effect
        // Kh_eff = Kh0 Ã— (1 - (P/P_cr)Â²)
        function calcEffectiveHorizontalStiffness(Kh0, N, P_cr) {
            const ratio = N / P_cr;
            return Kh0 * Math.max(0, 1 - ratio * ratio);
        }

        // State
        let state = {
            view: 'plan',
            scenario: 'normal',
            supports: [],
            force: 0,
            eccentricFactor: 0,
            buildingDisp: { x: 0, y: 0, rot: 0 },
            isAnimating: false,
            animPhase: 0
        };

        // Initialize supports with proper bearing design
        function initSupports(scenario) {
            state.supports = [];

            let reactions;
            if (scenario === 'normal') {
                reactions = [...NORMAL_REACTIONS];
            } else if (scenario === 'eccentric') {
                // Eccentric: increase left side, decrease right side
                reactions = [
                    NORMAL_REACTIONS[0] * 1.8,  // 8 - increase
                    NORMAL_REACTIONS[1] * 1.3,  // 11 - increase
                    NORMAL_REACTIONS[2] * 0.2,  // 25 - decrease significantly
                    NORMAL_REACTIONS[3] * 1.8,  // 4 - increase
                    NORMAL_REACTIONS[4] * 1.3,  // 16 - increase
                    NORMAL_REACTIONS[5] * 0.2   // 30 - decrease significantly
                ];
            } else if (scenario === 'max_torsion') {
                // Maximum torsion: diagonal pattern
                reactions = [
                    NORMAL_REACTIONS[0] * 2.0,  // 8 - max
                    NORMAL_REACTIONS[1] * 0.5,  // 11 - low
                    NORMAL_REACTIONS[2] * 0.1,  // 25 - min
                    NORMAL_REACTIONS[3] * 0.1,  // 4 - min
                    NORMAL_REACTIONS[4] * 0.5,  // 16 - low
                    NORMAL_REACTIONS[5] * 2.0   // 30 - max
                ];
            } else {
                reactions = [...NORMAL_REACTIONS];
            }

            SUPPORTS_CONFIG.forEach((cfg, i) => {
                const N = reactions[i];

                // Design bearing based on NORMAL load (for sizing)
                const designN = NORMAL_REACTIONS[i];
                const D = calcDiameter(designN);
                const A = Math.PI * Math.pow(D / 2, 2);
                const S = calcShapeFactor(D);
                const Kh0 = calcHorizontalStiffness(D);
                const Kv = calcVerticalStiffness(D);
                const P_cr = calcCriticalBucklingLoad(D);

                // Actual pressure under current load
                const actualPressure = (N * 1000) / (A * 1e6); // MPa

                // Effective stiffness under current load
                const ratio = N / P_cr;
                const Kh_eff = calcEffectiveHorizontalStiffness(Kh0, N, P_cr);
                const stiffnessRatio = Kh0 > 0 ? Kh_eff / Kh0 : 0;

                state.supports.push({
                    label: cfg.label,
                    x: cfg.x,
                    y: cfg.y,
                    isCenter: cfg.isCenter,
                    D: D,          // Design diameter (m)
                    D_mm: D * 1000, // Diameter in mm
                    A: A,          // Area (mÂ²)
                    S: S,          // Shape factor
                    N: N,          // Current axial load (kN)
                    designN: designN, // Design axial load (kN)
                    pressure: actualPressure, // Current pressure (MPa)
                    Kh0: Kh0,      // Baseline horizontal stiffness (kN/m)
                    Kh: Kh_eff,    // Effective horizontal stiffness (kN/m)
                    Kv: Kv,        // Vertical stiffness (kN/m)
                    P_cr: P_cr,    // Critical buckling load (kN)
                    ratio: ratio,  // P/P_cr ratio
                    stiffnessRatio: stiffnessRatio
                });
            });
        }

        // Apply eccentric factor for custom scenario
        function applyEccentricFactor(factor) {
            state.eccentricFactor = factor;
            const f = factor / 100;

            state.supports.forEach((s, i) => {
                let normalN = NORMAL_REACTIONS[i];
                let eccentricN;

                // Eccentric pattern: left side heavy, right side light
                if (s.x < 0) {
                    eccentricN = normalN * (1 + f * 1.0);
                } else if (s.x > 0) {
                    eccentricN = normalN * (1 - f * 0.8);
                } else {
                    eccentricN = normalN * (1 + f * 0.3);
                }

                s.N = Math.max(0.1, eccentricN);
                s.pressure = (s.N * 1000) / (s.A * 1e6);
                s.ratio = s.N / s.P_cr;
                s.Kh = calcEffectiveHorizontalStiffness(s.Kh0, s.N, s.P_cr);
                s.stiffnessRatio = s.Kh0 > 0 ? s.Kh / s.Kh0 : 0;
            });
        }

        // Calculate center of stiffness and eccentricity
        function calculateEccentricity() {
            let sumKx = 0, sumKy = 0, sumK = 0;

            state.supports.forEach(s => {
                sumKx += s.Kh * s.x;
                sumKy += s.Kh * s.y;
                sumK += s.Kh;
            });

            const Cs_x = sumK > 0 ? sumKx / sumK : 0;
            const Cs_y = sumK > 0 ? sumKy / sumK : 0;

            // Center of mass assumed at origin
            const ex = Cs_x;
            const ey = Cs_y;
            const e_magnitude = Math.sqrt(ex * ex + ey * ey);
            const e_ratio = e_magnitude / Math.sqrt(BUILDING_WIDTH * BUILDING_WIDTH + BUILDING_DEPTH * BUILDING_DEPTH) * 100;

            return { Cs_x, Cs_y, ex, ey, e_magnitude, e_ratio, totalK: sumK };
        }

        // DOM Elements
        const supportGrid = document.getElementById('support-grid');
        const totalWeightEl = document.getElementById('total-weight');
        const avgStiffnessEl = document.getElementById('avg-stiffness');
        const eccXEl = document.getElementById('ecc-x');
        const eccYEl = document.getElementById('ecc-y');
        const eccRatioEl = document.getElementById('ecc-ratio');
        const torsionAlert = document.getElementById('torsion-alert');
        const torsionText = document.getElementById('torsion-text');
        const forceSlider = document.getElementById('force-slider');
        const forceValue = document.getElementById('force-value');
        const eccentricSlider = document.getElementById('eccentric-slider');
        const eccentricValue = document.getElementById('eccentric-value');
        const btnAnimate = document.getElementById('btn-animate');
        const btnReset = document.getElementById('btn-reset');

        // Create support display cards
        function createSupportCards() {
            supportGrid.innerHTML = '';
            state.supports.forEach((s, i) => {
                const card = document.createElement('div');
                card.className = 'support-card normal';
                card.id = `support-card-${i}`;
                card.innerHTML = `
                    <div class="support-label">æ”¯åº§ ${s.label} (D=${s.D_mm.toFixed(0)}mm)</div>
                    <div class="support-value" id="support-value-${i}" style="color: #2ed573;">${s.N.toFixed(2)} kN</div>
                    <div class="support-detail" id="support-pressure-${i}">Ïƒ=${s.pressure.toFixed(1)} MPa</div>
                    <div class="support-stiffness" id="support-stiffness-${i}" style="color: #00d4ff;">Kh=${(s.stiffnessRatio * 100).toFixed(1)}%</div>
                `;
                supportGrid.appendChild(card);
            });
        }

        // Update display
        function updateDisplay() {
            const ecc = calculateEccentricity();

            // Update support cards
            let totalN = 0;
            let totalK = 0;

            state.supports.forEach((s, i) => {
                const card = document.getElementById(`support-card-${i}`);
                const valueEl = document.getElementById(`support-value-${i}`);
                const pressureEl = document.getElementById(`support-pressure-${i}`);
                const stiffEl = document.getElementById(`support-stiffness-${i}`);

                valueEl.textContent = s.N.toFixed(2) + ' kN';
                pressureEl.textContent = `Ïƒ=${s.pressure.toFixed(1)} MPa`;
                stiffEl.textContent = `Kh=${(s.stiffnessRatio * 100).toFixed(1)}%`;

                totalN += s.N;
                totalK += s.stiffnessRatio;

                // Color coding based on pressure
                if (s.pressure > 25 || s.stiffnessRatio < 0.5) {
                    card.className = 'support-card danger';
                    valueEl.style.color = '#ff6b6b';
                    pressureEl.style.color = '#ff6b6b';
                    stiffEl.style.color = '#ff6b6b';
                } else if (s.pressure > 18 || s.stiffnessRatio < 0.8) {
                    card.className = 'support-card warning';
                    valueEl.style.color = '#ffa502';
                    pressureEl.style.color = '#ffa502';
                    stiffEl.style.color = '#ffa502';
                } else {
                    card.className = 'support-card normal';
                    valueEl.style.color = '#2ed573';
                    pressureEl.style.color = '#888';
                    stiffEl.style.color = '#00d4ff';
                }
            });

            // Summary stats
            totalWeightEl.textContent = totalN.toFixed(2) + ' kN';
            avgStiffnessEl.textContent = ((totalK / state.supports.length) * 100).toFixed(1) + '%';

            // Eccentricity
            eccXEl.textContent = ecc.ex.toFixed(3) + ' m';
            eccYEl.textContent = ecc.ey.toFixed(3) + ' m';
            eccRatioEl.textContent = ecc.e_ratio.toFixed(1) + '%';

            // Torsion alert
            if (ecc.e_ratio > 3) {
                torsionAlert.classList.add('show');
                const Mt = Math.abs(state.force) * ecc.e_magnitude;
                torsionText.innerHTML = `åå¿ƒè· e = ${ecc.e_magnitude.toFixed(3)} m<br>
                    æ‰­è½¬åŠ›çŸ© M<sub>T</sub> = ${state.force.toFixed(0)} Ã— ${ecc.e_magnitude.toFixed(3)} = ${Mt.toFixed(1)} kNÂ·m`;
            } else {
                torsionAlert.classList.remove('show');
            }

            return ecc;
        }

        // Scenario buttons
        document.querySelectorAll('.scenario-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.scenario = btn.dataset.scenario;

                if (state.scenario === 'custom') {
                    eccentricSlider.disabled = false;
                } else {
                    eccentricSlider.disabled = true;
                    eccentricSlider.value = state.scenario === 'eccentric' ? 100 : 0;
                    eccentricValue.textContent = state.scenario === 'eccentric' ? '100%' : '0%';
                }

                initSupports(state.scenario);
                if (state.scenario === 'eccentric') {
                    applyEccentricFactor(100);
                }
                createSupportCards();
                updateDisplay();
                draw();
            });
        });

        // View tabs
        document.querySelectorAll('.view-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                state.view = tab.dataset.view;
                draw();
            });
        });

        // Sliders
        forceSlider.addEventListener('input', (e) => {
            state.force = parseFloat(e.target.value);
            forceValue.textContent = state.force.toFixed(0) + ' kN';
            updateDisplay();
            draw();
        });

        eccentricSlider.addEventListener('input', (e) => {
            const factor = parseFloat(e.target.value);
            eccentricValue.textContent = factor.toFixed(0) + '%';
            applyEccentricFactor(factor);
            createSupportCards();
            updateDisplay();
            draw();
        });

        // Animation
        let animationId = null;

        btnAnimate.addEventListener('click', () => {
            if (!state.isAnimating) {
                state.isAnimating = true;
                btnAnimate.textContent = 'â¸ æš‚åœ';
                animate();
            } else {
                state.isAnimating = false;
                btnAnimate.textContent = 'â–¶ ç»§ç»­';
                cancelAnimationFrame(animationId);
            }
        });

        btnReset.addEventListener('click', () => {
            state.isAnimating = false;
            cancelAnimationFrame(animationId);
            state.buildingDisp = { x: 0, y: 0, rot: 0 };
            state.animPhase = 0;
            state.force = 0;
            forceSlider.value = 0;
            forceValue.textContent = '0 kN';
            btnAnimate.textContent = 'â–¶ åœ°éœ‡æ¨¡æ‹Ÿ';
            updateDisplay();
            draw();
        });

        function animate() {
            if (!state.isAnimating) return;

            state.animPhase += 0.08;

            // Sinusoidal seismic force
            state.force = Math.sin(state.animPhase) * 80;
            forceSlider.value = state.force;
            forceValue.textContent = state.force.toFixed(0) + ' kN';

            const ecc = calculateEccentricity();

            // Building response
            const totalK = state.supports.reduce((sum, s) => sum + s.Kh, 0);
            const disp = state.force / (totalK > 0 ? totalK : 1);

            // Torsion response
            const torsionMoment = state.force * ecc.e_magnitude;
            const J = state.supports.reduce((sum, s) => sum + s.Kh * (s.x * s.x + s.y * s.y), 0);
            const rotation = J > 0 ? torsionMoment / J : 0;

            // Apply damping
            state.buildingDisp.x = state.buildingDisp.x * 0.9 + disp * 0.1;
            state.buildingDisp.rot = state.buildingDisp.rot * 0.9 + rotation * 0.1;

            updateDisplay();
            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Drawing
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (state.view === 'plan') {
                drawPlanView();
            } else if (state.view === 'forces') {
                drawForcesView();
            } else {
                drawStiffnessView();
            }
        }

        function drawPlanView() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 35; // pixels per meter

            ctx.save();
            ctx.translate(centerX + state.buildingDisp.x * scale * 10, centerY);
            ctx.rotate(state.buildingDisp.rot * 0.5);

            // Building outline
            const buildW = BUILDING_WIDTH * scale;
            const buildD = BUILDING_DEPTH * scale;

            ctx.fillStyle = 'rgba(61, 90, 128, 0.3)';
            ctx.fillRect(-buildW / 2, -buildD / 2, buildW, buildD);
            ctx.strokeStyle = '#5c7a99';
            ctx.lineWidth = 2;
            ctx.strokeRect(-buildW / 2, -buildD / 2, buildW, buildD);

            // Grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-buildW / 2, 0);
            ctx.lineTo(buildW / 2, 0);
            ctx.moveTo(0, -buildD / 2);
            ctx.lineTo(0, buildD / 2);
            ctx.stroke();

            // Draw supports
            const maxN = Math.max(...state.supports.map(s => s.N));
            const ecc = calculateEccentricity();

            state.supports.forEach(s => {
                const px = s.x * scale;
                const py = -s.y * scale; // Flip Y for screen coords

                const size = 15 + (s.N / maxN) * 15;

                // Color based on stiffness ratio
                let color;
                if (s.stiffnessRatio < 0.5) {
                    color = '#ff6b6b';
                } else if (s.stiffnessRatio < 0.8) {
                    color = '#ffa502';
                } else {
                    color = '#2ed573';
                }

                // Draw bearing
                ctx.beginPath();
                ctx.arc(px, py, size, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.font = 'bold 11px Inter';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(s.label, px, py + 4);
            });

            // Center of Mass (CM)
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#ffa502';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = 'bold 10px Inter';
            ctx.fillStyle = '#ffa502';
            ctx.fillText('CM', 15, 4);

            // Center of Stiffness (CS)
            const csX = ecc.Cs_x * scale;
            const csY = -ecc.Cs_y * scale;
            ctx.beginPath();
            ctx.arc(csX, csY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#f472b6';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = 'bold 10px Inter';
            ctx.fillStyle = '#f472b6';
            ctx.fillText('CS', csX + 15, csY + 4);

            // Eccentricity line
            if (ecc.e_magnitude > 0.01) {
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.moveTo(0, 0);
                ctx.lineTo(csX, csY);
                ctx.strokeStyle = '#f472b6';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.setLineDash([]);

                // e label
                ctx.font = '11px JetBrains Mono';
                ctx.fillStyle = '#f472b6';
                ctx.fillText(`e = ${ecc.e_magnitude.toFixed(3)}m`, (csX) / 2, (csY) / 2 - 10);
            }

            // Seismic force arrow
            if (Math.abs(state.force) > 1) {
                const arrowLen = Math.abs(state.force) * 0.8;
                const dir = state.force > 0 ? 1 : -1;

                ctx.beginPath();
                ctx.moveTo(-buildW / 2 - 30, 0);
                ctx.lineTo(-buildW / 2 - 30 + dir * arrowLen, 0);
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 4;
                ctx.stroke();

                // Arrow head
                ctx.beginPath();
                ctx.moveTo(-buildW / 2 - 30 + dir * arrowLen, 0);
                ctx.lineTo(-buildW / 2 - 30 + dir * arrowLen - dir * 10, -8);
                ctx.lineTo(-buildW / 2 - 30 + dir * arrowLen - dir * 10, 8);
                ctx.closePath();
                ctx.fillStyle = '#00d4ff';
                ctx.fill();

                ctx.font = 'bold 12px Inter';
                ctx.fillStyle = '#00d4ff';
                ctx.fillText(`F=${state.force.toFixed(0)}kN`, -buildW / 2 - 50, -20);
            }

            ctx.restore();

            // Legend
            ctx.font = '12px Inter';
            ctx.fillStyle = '#888';
            ctx.fillText('ä¿¯è§†å›¾ - æ”¯åº§å¸ƒç½®', 20, 30);

            // Color legend
            const legendY = canvas.height - 40;
            ctx.fillStyle = '#2ed573';
            ctx.fillRect(20, legendY, 12, 12);
            ctx.fillStyle = '#888';
            ctx.fillText('æ­£å¸¸', 38, legendY + 10);

            ctx.fillStyle = '#ffa502';
            ctx.fillRect(80, legendY, 12, 12);
            ctx.fillStyle = '#888';
            ctx.fillText('åˆšåº¦é™ä½', 98, legendY + 10);

            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(170, legendY, 12, 12);
            ctx.fillStyle = '#888';
            ctx.fillText('å±é™©', 188, legendY + 10);
        }

        function drawForcesView() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2 + 50;
            const scale = 35;

            // Title
            ctx.font = 'bold 14px Inter';
            ctx.fillStyle = '#888';
            ctx.fillText('æ”¯åº§ååŠ›åˆ†å¸ƒ (N)', 20, 30);

            // Draw bar chart
            const barWidth = 60;
            const maxN = Math.max(...state.supports.map(s => s.N));
            const startX = centerX - (state.supports.length * barWidth) / 2;

            state.supports.forEach((s, i) => {
                const x = startX + i * barWidth + barWidth / 2;
                const barHeight = (s.N / maxN) * 200;

                // Color based on stiffness
                let color;
                if (s.stiffnessRatio < 0.5) {
                    color = '#ff6b6b';
                } else if (s.stiffnessRatio < 0.8) {
                    color = '#ffa502';
                } else {
                    color = '#2ed573';
                }

                // Bar
                ctx.fillStyle = color;
                ctx.fillRect(x - 20, centerY - barHeight, 40, barHeight);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - 20, centerY - barHeight, 40, barHeight);

                // Value
                ctx.font = 'bold 11px JetBrains Mono';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(s.N.toFixed(1), x, centerY - barHeight - 8);

                // Label
                ctx.font = '12px Inter';
                ctx.fillStyle = '#888';
                ctx.fillText(s.label, x, centerY + 20);
            });

            // Baseline
            ctx.beginPath();
            ctx.moveTo(startX - 20, centerY);
            ctx.lineTo(startX + state.supports.length * barWidth + 20, centerY);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawStiffnessView() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2 + 50;

            // Title
            ctx.font = 'bold 14px Inter';
            ctx.fillStyle = '#888';
            ctx.fillText('æ°´å¹³åˆšåº¦åˆ†å¸ƒ K_h = K_0 Ã— (1 - (P/P_cr)Â²)', 20, 30);

            // Draw stiffness bars
            const barWidth = 60;
            const startX = centerX - (state.supports.length * barWidth) / 2;

            state.supports.forEach((s, i) => {
                const x = startX + i * barWidth + barWidth / 2;
                const barHeight = s.stiffnessRatio * 200;

                // Color
                let color;
                if (s.stiffnessRatio < 0.5) {
                    color = '#ff6b6b';
                } else if (s.stiffnessRatio < 0.8) {
                    color = '#ffa502';
                } else {
                    color = '#00d4ff';
                }

                // Full bar (reference)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(x - 20, centerY - 200, 40, 200);

                // Actual stiffness bar
                ctx.fillStyle = color;
                ctx.fillRect(x - 20, centerY - barHeight, 40, barHeight);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - 20, centerY - barHeight, 40, barHeight);

                // Value
                ctx.font = 'bold 11px JetBrains Mono';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText((s.stiffnessRatio * 100).toFixed(1) + '%', x, centerY - barHeight - 8);

                // P/P_cr ratio
                ctx.font = '10px JetBrains Mono';
                ctx.fillStyle = '#888';
                ctx.fillText(`P/P_cr=${(s.ratio * 100).toFixed(1)}%`, x, centerY + 35);

                // Label
                ctx.font = '12px Inter';
                ctx.fillStyle = '#888';
                ctx.fillText(s.label, x, centerY + 20);
            });

            // Baseline
            ctx.beginPath();
            ctx.moveTo(startX - 20, centerY);
            ctx.lineTo(startX + state.supports.length * barWidth + 20, centerY);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Formula reminder
            ctx.font = '12px JetBrains Mono';
            ctx.fillStyle = '#00d4ff';
            ctx.textAlign = 'left';
            ctx.fillText('K_h = K_0 Ã— (1 - (P/P_cr)Â²)', 20, canvas.height - 30);
        }

        // Initialize
        initSupports('normal');
        createSupportCards();
        updateDisplay();
        draw();
    </script>
</body>

</html>